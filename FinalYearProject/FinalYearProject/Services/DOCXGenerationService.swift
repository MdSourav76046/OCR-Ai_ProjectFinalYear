import Foundation
import UIKit

// MARK: - DOCX Generation Service
// Note: Creates RTF format which Microsoft Word can open
class DOCXGenerationService: ObservableObject {
    static let shared = DOCXGenerationService()
    
    @Published var isProcessing = false
    @Published var errorMessage = ""
    
    private init() {}
    
    // MARK: - Generate DOCX (RTF) from Text
    func generateDOCX(text: String, title: String) async throws -> URL {
        await MainActor.run {
            isProcessing = true
            errorMessage = ""
        }
        
        defer {
            Task { @MainActor in
                isProcessing = false
            }
        }
        
        // Create RTF content (can be opened by Word)
        let rtfContent = try createRTFContent(text: text, title: title)
        
        // Save to temporary directory with .docx extension
        let fileName = "\(title.replacingOccurrences(of: " ", with: "_"))_\(Date().timeIntervalSince1970).docx"
        let tempURL = FileManager.default.temporaryDirectory.appendingPathComponent(fileName)
        
        try rtfContent.write(to: tempURL, atomically: true, encoding: .utf8)
        
        return tempURL
    }
    
    // MARK: - Create RTF Content
    private func createRTFContent(text: String, title: String) throws -> String {
        // Get current date
        let dateFormatter = DateFormatter()
        dateFormatter.dateStyle = .long
        let dateString = dateFormatter.string(from: Date())
        
        // Create RTF header
        var rtf = "{\\rtf1\\ansi\\deff0\n"
        
        // Font table
        rtf += "{\\fonttbl{\\f0\\fswiss\\fcharset0 Helvetica;}{\\f1\\fmodern\\fcharset0 Courier;}}\n"
        
        // Color table
        rtf += "{\\colortbl;\\red0\\green0\\blue0;\\red128\\green128\\blue128;}\n"
        
        // Document settings
        rtf += "\\viewkind4\\uc1\\pard\\f0\\fs24\n"
        
        // Title - Bold and larger
        rtf += "\\b\\fs32 \(escapeRTF(title))\\b0\\fs24\\par\n"
        rtf += "\\par\n"
        
        // Date - Smaller and gray
        rtf += "\\cf2\\fs20 \(escapeRTF(dateString))\\cf1\\fs24\\par\n"
        rtf += "\\par\n"
        
        // Separator line
        rtf += "\\brdrb\\brdrs\\brdrw10\\brsp20\\par\n"
        rtf += "\\par\n"
        
        // Main content
        // Split into paragraphs and format
        let paragraphs = text.components(separatedBy: "\n\n")
        
        for paragraph in paragraphs {
            let trimmed = paragraph.trimmingCharacters(in: .whitespacesAndNewlines)
            if trimmed.isEmpty { continue }
            
            // Check if it's a heading (uppercase, short, or ends with colon)
            if isHeading(trimmed) {
                // Format as heading
                rtf += "\\b\\fs28 \(escapeRTF(trimmed))\\b0\\fs24\\par\n"
                rtf += "\\par\n"
            } else {
                // Regular paragraph with indentation
                rtf += "\\fi720 \(escapeRTF(trimmed))\\par\n"
                rtf += "\\par\n"
            }
        }
        
        // Footer
        rtf += "\\par\n"
        rtf += "\\pard\\qc\\cf2\\fs18 Generated by OCR App - \(escapeRTF(dateString))\\cf1\\fs24\\par\n"
        
        // Close RTF
        rtf += "}\n"
        
        return rtf
    }
    
    // MARK: - Check if text is a heading
    private func isHeading(_ text: String) -> Bool {
        // Heading characteristics
        let isShort = text.count < 80
        let isUppercase = text.uppercased() == text && text.count > 3
        let endsWithColon = text.hasSuffix(":")
        let hasHeadingKeywords = text.lowercased().contains("introduction") ||
                                 text.lowercased().contains("conclusion") ||
                                 text.lowercased().contains("summary") ||
                                 text.lowercased().contains("chapter") ||
                                 text.lowercased().contains("section")
        
        return (isShort && (isUppercase || endsWithColon)) || hasHeadingKeywords
    }
    
    // MARK: - Escape RTF special characters
    private func escapeRTF(_ text: String) -> String {
        var escaped = text
        
        // Escape backslash, braces, and special chars
        escaped = escaped.replacingOccurrences(of: "\\", with: "\\\\")
        escaped = escaped.replacingOccurrences(of: "{", with: "\\{")
        escaped = escaped.replacingOccurrences(of: "}", with: "\\}")
        escaped = escaped.replacingOccurrences(of: "\n", with: "\\par\n")
        
        return escaped
    }
}

// MARK: - Custom Errors
enum DOCXGenerationError: Error, LocalizedError {
    case emptyText
    case generationFailed
    case saveFailed
    
    var errorDescription: String? {
        switch self {
        case .emptyText:
            return "Cannot generate document from empty text"
        case .generationFailed:
            return "Failed to generate Word document"
        case .saveFailed:
            return "Failed to save document file"
        }
    }
}

